import { PDFDocument, StandardFonts, rgb } from "pdf-lib";

export async function handler(event) {
  // Handle CORS
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'POST, OPTIONS'
      },
      body: ''
    };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  try {
    const { claimInfo, evidenceList, aiSummary } = JSON.parse(event.body);
    
    // Create a new PDF document
    const pdfDoc = await PDFDocument.create();
    const page = pdfDoc.addPage([595, 842]); // A4 size
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    
    let y = 800;
    const margin = 50;
    const pageWidth = 595 - (margin * 2);

    // Helper function to add text with word wrapping
    const addText = (text, x, y, size = 12, fontType = font, color = rgb(0, 0, 0)) => {
      const words = text.split(' ');
      let currentLine = '';
      let currentY = y;
      
      for (const word of words) {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        const textWidth = fontType.widthOfTextAtSize(testLine, size);
        
        if (textWidth > pageWidth && currentLine) {
          page.drawText(currentLine, { x, y: currentY, size, font: fontType, color });
          currentLine = word;
          currentY -= size + 2;
        } else {
          currentLine = testLine;
        }
      }
      
      if (currentLine) {
        page.drawText(currentLine, { x, y: currentY, size, font: fontType, color });
        currentY -= size + 2;
      }
      
      return currentY;
    };

    // Title
    y = addText("CLAIM EVIDENCE SUMMARY REPORT", margin, y, 20, boldFont, rgb(0.1, 0.2, 0.4));
    y -= 20;

    // Claim Information Section
    y = addText("CLAIM INFORMATION", margin, y, 16, boldFont);
    y -= 10;
    
    const claimDetails = [
      `Claim Number: ${claimInfo.claimNumber || 'Not provided'}`,
      `Date of Loss: ${claimInfo.dateOfLoss || 'Not provided'}`,
      `Insurance Company: ${claimInfo.insuranceCompany || 'Not provided'}`,
      `Policy Number: ${claimInfo.policyNumber || 'Not provided'}`,
      `Claimant: ${claimInfo.name || 'Not provided'}`,
      `Contact: ${claimInfo.email || 'Not provided'} | ${claimInfo.phone || 'Not provided'}`
    ];
    
    for (const detail of claimDetails) {
      y = addText(detail, margin, y, 12);
      y -= 5;
    }
    
    y -= 20;

    // AI Summary Section
    y = addText("AI ANALYSIS SUMMARY", margin, y, 16, boldFont);
    y -= 10;
    y = addText(aiSummary || "No AI analysis available", margin, y, 12);
    y -= 20;

    // Evidence Files Section
    y = addText("EVIDENCE FILES", margin, y, 16, boldFont);
    y -= 10;
    
    if (evidenceList && evidenceList.length > 0) {
      // Group by category
      const categories = {};
      evidenceList.forEach(file => {
        if (!categories[file.category]) {
          categories[file.category] = [];
        }
        categories[file.category].push(file);
      });

      for (const [category, files] of Object.entries(categories)) {
        y = addText(`${category.toUpperCase()} (${files.length} files)`, margin, y, 14, boldFont);
        y -= 5;
        
        for (const file of files) {
          const fileInfo = `â€¢ ${file.file_name}`;
          y = addText(fileInfo, margin + 20, y, 11);
          y -= 3;
          
          if (file.ai_summary) {
            y = addText(`  Summary: ${file.ai_summary}`, margin + 20, y, 10, font, rgb(0.3, 0.3, 0.3));
            y -= 3;
          }
          
          if (file.notes) {
            y = addText(`  Notes: ${file.notes}`, margin + 20, y, 10, font, rgb(0.3, 0.3, 0.3));
            y -= 3;
          }
          
          y -= 5;
        }
        y -= 10;
      }
    } else {
      y = addText("No evidence files uploaded", margin, y, 12);
    }

    // Footer
    y = 50;
    const currentDate = new Date().toLocaleDateString();
    y = addText(`Report generated on ${currentDate}`, margin, y, 10, font, rgb(0.5, 0.5, 0.5));
    y = addText("Generated by ClaimNavigatorAI Evidence Organizer", margin, y, 10, font, rgb(0.5, 0.5, 0.5));

    // Save the PDF
    const pdfBytes = await pdfDoc.save();
    
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Content-Type': 'application/pdf',
        'Content-Disposition': 'attachment; filename="evidence-summary-report.pdf"'
      },
      body: Buffer.from(pdfBytes).toString('base64'),
      isBase64Encoded: true
    };

  } catch (error) {
    console.error('PDF generation error:', error);
    
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ 
        error: 'PDF generation failed',
        details: error.message
      })
    };
  }
}
