<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>üìÇ Evidence Organizer ‚Äî ClaimNavigatorAI</title>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#0f172a',  /* dark navy */
            accent:  '#1e40af',
            border:  '#e5e7eb',
            bglight: '#f9fafb',
          },
          boxShadow: {
            soft: '0 4px 16px rgba(0,0,0,0.06)'
          },
          borderRadius: {
            '2xl': '1rem'
          }
        }
      }
    }
  </script>

  <!-- Chart.js for timeline -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- JSZip for "Download All" -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <!-- Optional global config (set these in /app/config.js or similar) -->
  <!-- <script>
    window.SUPABASE_URL = "https://YOUR_SUPABASE_PROJECT.supabase.co";
    window.SUPABASE_ANON_KEY = "YOUR_PUBLIC_ANON_KEY";
  </script> -->

  <!-- Supabase (optional; auto-fallback to local if not configured) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.min.js"></script>

  <style>
    /* Minimal extra polish */
    .badge { @apply inline-block text-xs font-semibold px-2 py-1 rounded-md; }
    .badge-blue { @apply bg-blue-100 text-blue-800; }
    .badge-green { @apply bg-green-100 text-green-800; }
    .badge-yellow { @apply bg-yellow-100 text-yellow-800; }
    .badge-gray { @apply bg-gray-100 text-gray-800; }
  </style>
</head>
<body class="bg-white text-slate-800">
  <!-- Header -->
  <header class="bg-primary text-white">
    <div class="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between">
      <h1 class="text-lg md:text-xl font-semibold flex items-center gap-2">
        üìÇ Evidence Organizer
      </h1>
      <nav>
        <a href="/app/response-center.html" class="underline text-sm">‚Üê Resource Center</a>
      </nav>
    </div>
  </header>

  <main class="max-w-6xl mx-auto px-4 py-6 space-y-8">
    <!-- Claim Information -->
    <section class="bg-bglight p-6 rounded-2xl shadow-soft">
      <div class="flex items-center justify-between mb-4">
        <h2 class="text-xl font-semibold text-primary">Claim Information</h2>
        <div id="claimSaved" class="text-sm text-green-700 hidden">‚úì Saved</div>
      </div>

      <div class="grid md:grid-cols-4 gap-4">
        <label class="text-sm">Your Name
          <input id="claimantName" class="w-full border border-border rounded-lg p-2 focus:ring-2 focus:ring-accent" />
        </label>
        <label class="text-sm">Policy #
          <input id="policyNumber" class="w-full border border-border rounded-lg p-2 focus:ring-2 focus:ring-accent" />
        </label>
        <label class="text-sm">Claim #
          <input id="claimNumber" class="w-full border border-border rounded-lg p-2 focus:ring-2 focus:ring-accent" />
        </label>
        <label class="text-sm">Date of Loss
          <input id="dateOfLoss" type="date" class="w-full border border-border rounded-lg p-2 focus:ring-2 focus:ring-accent" />
        </label>
        <label class="text-sm">Insurance Company
          <input id="insurerName" class="w-full border border-border rounded-lg p-2 focus:ring-2 focus:ring-accent" />
        </label>
        <label class="text-sm">Phone Number
          <input id="phoneNumber" type="tel" class="w-full border border-border rounded-lg p-2 focus:ring-2 focus:ring-accent" />
        </label>
        <label class="text-sm">Email Address
          <input id="email" type="email" class="w-full border border-border rounded-lg p-2 focus:ring-2 focus:ring-accent" />
        </label>
        <label class="text-sm">Your Address
          <input id="claimantAddress" class="w-full border border-border rounded-lg p-2 focus:ring-2 focus:ring-accent" />
        </label>
      </div>
    </section>

    <!-- Evidence Upload -->
    <section class="bg-bglight p-6 rounded-2xl shadow-soft">
      <h2 class="text-xl font-semibold text-primary mb-4">Evidence Upload</h2>

      <div id="uploadZone"
           class="border-2 border-dashed border-accent rounded-2xl p-10 text-center text-slate-500 cursor-pointer hover:bg-bglight transition">
        <p class="mb-2">Drop files here or click to upload</p>
        <p class="text-xs">Accepted: PDF, JPG, PNG, JPEG, HEIC, DOCX, XLSX, ZIP</p>
        <input id="fileInput" type="file" multiple
               accept=".pdf,.jpg,.jpeg,.png,.heic,.doc,.docx,.xls,.xlsx,.zip"
               class="hidden"/>
      </div>

      <div class="flex items-center gap-3 mt-4">
        <button id="btnCategorize"
                class="bg-accent text-white px-4 py-2 rounded-xl hover:bg-blue-700 transition">
          Categorize with AI
        </button>
        <button id="btnCheck"
                class="bg-primary text-white px-4 py-2 rounded-xl hover:bg-slate-800 transition">
          Check My Evidence
        </button>
        <button id="btnSummary"
                class="bg-green-600 text-white px-4 py-2 rounded-xl hover:bg-green-700 transition">
          Generate Summary (PDF)
        </button>
        <button id="btnDownloadAll"
                class="bg-yellow-600 text-white px-4 py-2 rounded-xl hover:bg-yellow-700 transition">
          Download All (ZIP)
        </button>
        <button id="btnShare"
                class="bg-slate-700 text-white px-4 py-2 rounded-xl hover:bg-slate-800 transition">
          Generate Secure Share Link
        </button>
      </div>

      <!-- File cards -->
      <div id="fileList" class="grid md:grid-cols-3 gap-4 mt-6"></div>
    </section>

    <!-- Evidence Dashboard -->
    <section class="bg-bglight p-6 rounded-2xl shadow-soft">
      <h2 class="text-xl font-semibold text-primary mb-4">Evidence Dashboard</h2>

      <div id="summaryBar" class="text-sm mb-4 text-slate-700">
        Total Files: <span id="statTotal">0</span> |
        Photos: <span id="statPhotos">0</span> |
        Documents: <span id="statDocs">0</span> |
        Receipts: <span id="statReceipts">0</span> |
        Missing (AI): <span id="statMissing">0</span>
      </div>

      <!-- Category grid -->
      <div id="categoryGrid" class="grid md:grid-cols-3 gap-4"></div>

      <!-- Timeline -->
      <canvas id="timeline" class="w-full h-64 mt-6"></canvas>
    </section>

    <!-- AI Results -->
    <section class="bg-bglight p-6 rounded-2xl shadow-soft">
      <h2 class="text-xl font-semibold text-primary mb-4">AI Results</h2>
      <div id="aiResults" class="prose max-w-none text-sm"></div>
    </section>
  </main>

  <script>
    /*****************************************************************
     * Minimal utility + state
     *****************************************************************/
    const el = sel => document.querySelector(sel);
    const els = sel => [...document.querySelectorAll(sel)];

    const state = {
      claim: {
        claimantName: "",
        policyNumber: "",
        claimNumber: "",
        dateOfLoss: "",
        insurerName: "",
        phoneNumber: "",
        email: "",
        claimantAddress: ""
      },
      files: /** @type {Array<{
        id:string, file?:File, name:string, size:number, type:string,
        createdAt:string, category?:string, tags?:string[], notes?:string,
        before?:boolean, after?:boolean, supabasePath?:string, blobUrl?:string
      }>} */([]),
      chart: null,
      missingCount: 0
    };

    // Load persisted claim info (local fallback)
    function loadClaimFromLocal() {
      try {
        const raw = localStorage.getItem('cnai_claim_info');
        if (raw) state.claim = { ...state.claim, ...JSON.parse(raw) };
      } catch {}
    }
    function saveClaimLocal() {
      localStorage.setItem('cnai_claim_info', JSON.stringify(state.claim));
      el('#claimSaved').classList.remove('hidden');
      setTimeout(()=>el('#claimSaved').classList.add('hidden'), 1200);
    }

    // Hook claim inputs
    function bindClaimInputs() {
      const map = {
        claimantName: '#claimantName', policyNumber: '#policyNumber',
        claimNumber: '#claimNumber', dateOfLoss: '#dateOfLoss',
        insurerName: '#insurerName', phoneNumber: '#phoneNumber',
        email: '#email', claimantAddress: '#claimantAddress'
      };
      for (const k in map) {
        const input = el(map[k]);
        if (!input) continue;
        input.value = state.claim[k] || '';
        input.addEventListener('input', () => {
          state.claim[k] = input.value.trim();
          saveClaimLocal();
          supabaseUpsertClaimDebounced();
        });
      }
    }

    /*****************************************************************
     * Supabase (optional)
     *****************************************************************/
    let supabase = null;
    let claimRowId = null; // will hold claim_metadata.id if persisted

    if (window.SUPABASE_URL && window.SUPABASE_ANON_KEY) {
      supabase = window.supabase.createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY);
    }

    // Debounced upsert to claim_metadata
    const supabaseUpsertClaimDebounced = debounce(async () => {
      if (!supabase) return;
      try {
        const payload = {
          name: state.claim.claimantName || null,
          policy_number: state.claim.policyNumber || null,
          claim_number: state.claim.claimNumber || null,
          date_of_loss: state.claim.dateOfLoss || null,
          insurance_company: state.claim.insurerName || null,
          phone: state.claim.phoneNumber || null,
          email: state.claim.email || null,
          address: state.claim.claimantAddress || null
        };
        // If we already created a row, update it
        if (claimRowId) {
          await supabase.from('claim_metadata').update(payload).eq('id', claimRowId);
        } else {
          const { data, error } = await supabase.from('claim_metadata').insert(payload).select('id').single();
          if (!error && data?.id) claimRowId = data.id;
        }
      } catch (e) {
        console.warn('Supabase upsert claim failed (non-fatal):', e.message);
      }
    }, 600);

    async function supabaseUploadFile(file, name) {
      if (!supabase) return null;
      try {
        const bucket = 'evidence'; // ensure this bucket exists
        const path = `${Date.now()}_${sanitizeName(name)}`;
        const { error } = await supabase.storage.from(bucket).upload(path, file, {
          contentType: file.type || 'application/octet-stream',
          upsert: false
        });
        if (error) throw error;
        const { data: pub } = supabase.storage.from(bucket).getPublicUrl(path);
        return { path, publicUrl: pub?.publicUrl || null };
      } catch (e) {
        console.warn('Supabase upload failed (continuing locally):', e.message);
        return null;
      }
    }

    async function supabaseSaveEvidenceMeta(item) {
      if (!supabase) return;
      try {
        const payload = {
          claim_id: claimRowId || null,
          file_name: item.name,
          file_url: item.supabasePath || null,
          category: item.category || null,
          tags: item.tags || null,
          ai_summary: item.ai_summary || null,
          notes: item.notes || null
        };
        await supabase.from('evidence_files').insert(payload);
      } catch (e) {
        console.warn('Supabase insert evidence meta failed:', e.message);
      }
    }

    /*****************************************************************
     * Upload & file list
     *****************************************************************/
    const uploadZone = el('#uploadZone');
    const fileInput  = el('#fileInput');
    uploadZone.addEventListener('click', () => fileInput.click());
    uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.classList.add('bg-bglight'); });
    uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('bg-bglight'));
    uploadZone.addEventListener('drop', async (e) => {
      e.preventDefault();
      uploadZone.classList.remove('bg-bglight');
      await addFiles([...e.dataTransfer.files]);
    });
    fileInput.addEventListener('change', async () => {
      await addFiles([...fileInput.files]);
      fileInput.value = "";
    });

    async function addFiles(files) {
      for (const f of files) {
        const id = crypto.randomUUID();
        const name = f.name;
        const item = {
          id, file: f, name, size: f.size, type: f.type || 'application/octet-stream',
          createdAt: new Date().toISOString(),
          notes: '', before: false, after: false
        };

        // for local preview
        try { item.blobUrl = URL.createObjectURL(f); } catch {}

        // optional: upload to Supabase storage
        const su = await supabaseUploadFile(f, name);
        if (su?.path) item.supabasePath = su.path;

        state.files.push(item);
        renderFileCard(item);
        updateDashboard();
      }
    }

    function renderFileCard(item) {
      const wrap = document.createElement('div');
      wrap.className = "bg-white border border-border rounded-xl p-4 shadow-sm hover:shadow-md";
      wrap.dataset.id = item.id;

      const isImage = (item.type||'').startsWith('image/');
      const preview = isImage && item.blobUrl
        ? `<img src="${item.blobUrl}" class="w-full h-32 object-cover rounded-lg mb-3" alt="">`
        : `<div class="w-full h-32 flex items-center justify-center bg-bglight rounded-lg mb-3 text-xs text-slate-500">No preview</div>`;

      const badgeClass = categoryBadgeClass(item.category);

      wrap.innerHTML = `
        ${preview}
        <div class="flex items-center justify-between gap-2">
          <input class="flex-1 border border-border rounded-lg p-2 text-sm" value="${escapeHtml(item.name)}" data-role="filename"/>
        </div>

        <div class="mt-2 flex items-center gap-2 text-xs">
          <span class="badge ${badgeClass}" data-role="category">${item.category || 'Uncategorized'}</span>
          <span class="text-slate-500">${formatBytes(item.size)}</span>
        </div>

        <textarea class="mt-3 w-full border border-border rounded-lg p-2 text-sm" rows="2" placeholder="Notes/caption..." data-role="notes">${item.notes || ''}</textarea>

        <div class="mt-3 flex items-center justify-between">
          <div class="flex items-center gap-3 text-sm">
            <label class="flex items-center gap-1">
              <input type="checkbox" data-role="before" ${item.before?'checked':''}/> Before
            </label>
            <label class="flex items-center gap-1">
              <input type="checkbox" data-role="after" ${item.after?'checked':''}/> After
            </label>
          </div>
          <button class="text-red-600 hover:underline text-sm" data-role="delete">Delete</button>
        </div>
      `;

      const list = el('#fileList');
      list.prepend(wrap);

      // wire inputs
      wrap.querySelector('[data-role="filename"]').addEventListener('input', (e) => {
        item.name = e.target.value.trim();
      });
      wrap.querySelector('[data-role="notes"]').addEventListener('input', (e) => {
        item.notes = e.target.value;
      });
      wrap.querySelector('[data-role="before"]').addEventListener('change', (e) => {
        item.before = e.target.checked;
      });
      wrap.querySelector('[data-role="after"]').addEventListener('change', (e) => {
        item.after = e.target.checked;
      });
      wrap.querySelector('[data-role="delete"]').addEventListener('click', () => {
        state.files = state.files.filter(x => x.id !== item.id);
        wrap.remove();
        updateDashboard();
      });
    }

    /*****************************************************************
     * AI: categorize / completeness / summary (PDF)
     *****************************************************************/
    el('#btnCategorize').addEventListener('click', async () => {
      if (!state.files.length) return alert('Add files first.');
      // Categorize each (by filename; server may perform OCR)
      const tasks = state.files.map(async (f) => {
        const res = await fetch('/.netlify/functions/ai-categorize-evidence', {
          method: 'POST', headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ fileName: f.name, ocrText: null })
        });
        if (!res.ok) throw new Error('AI categorize failed');
        const data = await res.json();
        f.category = data.category || f.category || 'Other';
        f.tags = data.tags || [];
        f.ai_summary = data.summary || null;

        // update card badge
        const card = document.querySelector(`[data-id="${f.id}"]`);
        if (card) {
          const badge = card.querySelector('[data-role="category"]');
          badge.textContent = f.category;
          badge.className = `badge ${categoryBadgeClass(f.category)}`;
        }

        // persist metadata (optional)
        await supabaseSaveEvidenceMeta(f);
      });

      try {
        await Promise.all(tasks);
      } catch (e) {
        console.warn(e.message);
      }
      updateDashboard();
      el('#aiResults').innerHTML = `<div class="text-green-700">AI categorization complete.</div>`;
    });

    el('#btnCheck').addEventListener('click', async () => {
      if (!state.files.length) return alert('Add files first.');
      const cats = [...new Set(state.files.map(f => (f.category||'Other')))];
      const claimType = 'Property'; // can be refined from claim metadata

      const res = await fetch('/.netlify/functions/ai-evidence-check', {
        method: 'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ claimType, uploadedCategories: cats })
      });
      if (!res.ok) {
        el('#aiResults').innerHTML = `<div class="text-red-700">AI completeness check failed.</div>`;
        return;
      }
      const data = await res.json();
      state.missingCount = (data.missing||[]).length;
      updateDashboard();

      el('#aiResults').innerHTML = `
        <div class="mb-2"><strong>Missing:</strong> ${(data.missing||[]).join(', ') || 'None'}</div>
        <div><strong>Recommendations:</strong><ul class="list-disc pl-5">
          ${(data.recommendations||[]).map(x=>`<li>${escapeHtml(x)}</li>`).join('') || '<li>None</li>'}
        </ul></div>
      `;
    });

    el('#btnSummary').addEventListener('click', async () => {
      if (!state.files.length) return alert('Add files first.');
      const claimInfo = {
        claimNumber: state.claim.claimNumber || 'Not provided',
        dateOfLoss: state.claim.dateOfLoss || 'Not provided'
      };
      const evidenceList = state.files.map(f => ({
        category: f.category || 'Other',
        fileName: f.name,
        notes: f.notes || ''
      }));
      const aiSummary = buildAISummaryStub();

      const res = await fetch('/.netlify/functions/generate-evidence-report', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ claimInfo, evidenceList, aiSummary })
      });
      if (!res.ok) {
        el('#aiResults').innerHTML = `<div class="text-red-700">PDF generation failed.</div>`;
        return;
      }
      const b64 = await res.text();
      const byteChars = atob(b64);
      const byteNums = new Array(byteChars.length);
      for (let i = 0; i < byteChars.length; i++) byteNums[i] = byteChars.charCodeAt(i);
      const blob = new Blob([new Uint8Array(byteNums)], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `Evidence_Summary_${Date.now()}.pdf`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    });

    el('#btnDownloadAll').addEventListener('click', async () => {
      if (!state.files.length) return alert('Add files first.');
      const zip = new JSZip();
      for (const f of state.files) {
        if (f.file) {
          zip.file(sanitizeName(f.name || 'file'), f.file);
        }
      }
      const blob = await zip.generateAsync({type:"blob"});
      saveAs(blob, `ClaimEvidence_${Date.now()}.zip`);
    });

    el('#btnShare').addEventListener('click', async () => {
      if (!supabase) {
        alert('Secure share requires Supabase storage configured.');
        return;
      }
      // Try to create signed links if file on Supabase
      const bucket = 'evidence';
      const links = [];
      for (const f of state.files) {
        if (!f.supabasePath) continue;
        try {
          const { data, error } = await supabase.storage.from(bucket).createSignedUrl(f.supabasePath, 60 * 60 * 24);
          if (error) throw error;
          links.push(data.signedUrl);
        } catch (e) { console.warn(e.message); }
      }
      if (!links.length) {
        alert('No Supabase-backed files found to sign.');
        return;
      }
      const html = `<p class="text-sm mb-2">Share these secure links (24h):</p><ul class="list-disc pl-5 text-sm">${links.map(u=>`<li><a class="text-accent underline break-all" href="${u}" target="_blank" rel="noopener">Signed file</a></li>`).join('')}</ul>`;
      el('#aiResults').innerHTML = html;
    });

    /*****************************************************************
     * Dashboard
     *****************************************************************/
    function updateDashboard() {
      const total = state.files.length;
      const photos = state.files.filter(f => isPhoto(f)).length;
      const docs   = state.files.filter(f => isDoc(f)).length;
      const receipts = state.files.filter(f => /(receipt|invoice|payment)/i.test([f.name, ...(f.tags||[])].join(' '))).length;

      el('#statTotal').textContent = total;
      el('#statPhotos').textContent = photos;
      el('#statDocs').textContent = docs;
      el('#statReceipts').textContent = receipts;
      el('#statMissing').textContent = state.missingCount || 0;

      // Category grid
      const groups = groupByCategory(state.files);
      const grid = el('#categoryGrid');
      grid.innerHTML = Object.keys(groups).sort().map(cat => {
        const lastDate = groups[cat].map(x=>x.createdAt).sort().slice(-1)[0];
        return `
          <div class="bg-white border border-border rounded-xl p-4 shadow-sm">
            <div class="flex items-center justify-between mb-2">
              <div class="font-semibold">${escapeHtml(cat)}</div>
              <span class="badge ${categoryBadgeClass(cat)}">${groups[cat].length}</span>
            </div>
            <div class="text-xs text-slate-500">Last upload: ${lastDate ? new Date(lastDate).toLocaleString() : '‚Äî'}</div>
          </div>
        `;
      }).join('');

      // Timeline
      const byDay = {};
      state.files.forEach(f => {
        const k = (new Date(f.createdAt)).toISOString().slice(0,10);
        byDay[k] = (byDay[k]||0) + 1;
      });
      const labels = Object.keys(byDay).sort();
      const data = labels.map(k => byDay[k]);

      const ctx = el('#timeline').getContext('2d');
      if (state.chart) state.chart.destroy();
      state.chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [{ label: 'Uploads', data }]
        },
        options: {
          responsive: true,
          plugins: { legend: { display: false } },
          scales: { y: { beginAtZero: true, precision: 0 } }
        }
      });
    }

    /*****************************************************************
     * Helpers
     *****************************************************************/
    function categoryBadgeClass(cat = '') {
      if (/photo|image|video/i.test(cat)) return 'badge-blue';
      if (/invoice|estimate|document|pdf|doc/i.test(cat)) return 'badge-green';
      if (/receipt|payment|ale|expense/i.test(cat)) return 'badge-yellow';
      return 'badge-gray';
    }
    function isPhoto(f){ return /image\//i.test(f.type) || /photo|image|jpg|jpeg|png|heic/i.test(f.name); }
    function isDoc(f){ return /pdf|doc|docx|xls|xlsx/i.test(f.name); }
    function groupByCategory(arr) {
      return arr.reduce((acc, it) => {
        const c = it.category || 'Other';
        (acc[c] ||= []).push(it);
        return acc;
      }, {});
    }
    function formatBytes(b) {
      if (b < 1024) return b + ' B';
      if (b < 1024*1024) return (b/1024).toFixed(1)+' KB';
      if (b < 1024*1024*1024) return (b/1024/1024).toFixed(1)+' MB';
      return (b/1024/1024/1024).toFixed(1)+' GB';
    }
    function sanitizeName(n){ return n.replace(/[^\w\-.]+/g,'_'); }
    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
    function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }

    function buildAISummaryStub(){
      // Quick narrative if function output not yet used
      const start = state.files.map(f=>new Date(f.createdAt)).sort((a,b)=>a-b)[0];
      const end   = state.files.map(f=>new Date(f.createdAt)).sort((a,b)=>b-a)[0];
      const photos = state.files.filter(isPhoto).length;
      const docs   = state.files.filter(isDoc).length;
      const range  = start && end ? `${start.toLocaleDateString()}‚Äì${end.toLocaleDateString()}` : 'N/A';
      return `Between ${range}, ${state.files.length} files were documented, including ${photos} photos and ${docs} documents. Evidence shows progression of damage and supporting paperwork for evaluation.`;
    }

    /*****************************************************************
     * Init
     *****************************************************************/
    loadClaimFromLocal();
    bindClaimInputs();
    updateDashboard();
  </script>
</body>
</html>
