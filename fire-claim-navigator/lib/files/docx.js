const { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, WidthType } = require('docx');

// Convert structured document data to DOCX buffer
async function htmlToDocxBuffer(docData) {
  try {
    const { title, sections, policyholderName, docType } = docData;

    // Create document
    const doc = new Document({
      sections: [{
        properties: {},
        children: [
          // Title
          new Paragraph({
            children: [
              new TextRun({
                text: title || docType.replace('-', ' ').toUpperCase(),
                bold: true,
                size: 32
              })
            ],
            heading: HeadingLevel.TITLE,
            spacing: {
              after: 400
            }
          }),

          // Policyholder info header
          ...(policyholderName ? [
            new Paragraph({
              children: [
                new TextRun({
                  text: `Policyholder: ${policyholderName}`,
                  bold: true,
                  size: 24
                })
              ],
              spacing: {
                after: 200
              }
            })
          ] : []),

          // Process sections
          ...sections.map(section => {
            if (section.type === 'heading') {
              return new Paragraph({
                children: [
                  new TextRun({
                    text: section.text,
                    bold: true,
                    size: section.level === 1 ? 28 : section.level === 2 ? 24 : 20
                  })
                ],
                heading: section.level === 1 ? HeadingLevel.HEADING_1 : 
                        section.level === 2 ? HeadingLevel.HEADING_2 : HeadingLevel.HEADING_3,
                spacing: {
                  before: 300,
                  after: 200
                }
              });
            } else if (section.type === 'paragraph') {
              return new Paragraph({
                children: [
                  new TextRun({
                    text: section.text,
                    size: 22
                  })
                ],
                spacing: {
                  after: 200
                }
              });
            } else if (section.type === 'table' && section.rows) {
              return new Table({
                rows: section.rows.map(row => new TableRow({
                  children: row.cells.map(cell => new TableCell({
                    children: [
                      new Paragraph({
                        children: [
                          new TextRun({
                            text: cell,
                            size: 20
                          })
                        ]
                      })
                    ],
                    width: {
                      size: 100 / row.cells.length,
                      type: WidthType.PERCENTAGE
                    }
                  }))
                })),
                width: {
                  size: 100,
                  type: WidthType.PERCENTAGE
                }
              });
            } else if (section.type === 'list') {
              return new Paragraph({
                children: [
                  new TextRun({
                    text: `• ${section.text}`,
                    size: 22
                  })
                ],
                spacing: {
                  after: 100
                }
              });
            }
            return null;
          }).filter(Boolean),

          // Disclaimer
          new Paragraph({
            children: [
              new TextRun({
                text: 'This document was generated by AI for informational purposes. Review before submission.',
                size: 18,
                italics: true
              })
            ],
            spacing: {
              before: 400,
              after: 200
            }
          }),

          new Paragraph({
            children: [
              new TextRun({
                text: 'Este documento fue generado por IA con fines informativos. Revíselo antes de presentarlo.',
                size: 18,
                italics: true
              })
            ],
            spacing: {
              after: 200
            }
          })
        ]
      }]
    });

    // Generate buffer
    const buffer = await Packer.toBuffer(doc);
    return buffer;
  } catch (error) {
    console.error('DOCX generation error:', error);
    throw new Error(`DOCX generation failed: ${error.message}`);
  }
}

// Parse HTML content into structured sections for DOCX
function parseHtmlToSections(html) {
  const sections = [];
  
  // Remove HTML tags and split by lines
  const lines = html
    .replace(/<[^>]*>/g, '')
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .split('\n');

  let currentSection = null;

  lines.forEach(line => {
    const trimmedLine = line.trim();
    if (!trimmedLine) return;

    // Detect headings
    if (trimmedLine.startsWith('**') && trimmedLine.endsWith('**')) {
      if (currentSection) sections.push(currentSection);
      currentSection = {
        type: 'heading',
        text: trimmedLine.replace(/\*\*/g, ''),
        level: 2
      };
    } else if (trimmedLine.startsWith('#')) {
      if (currentSection) sections.push(currentSection);
      const level = (trimmedLine.match(/^#+/) || [''])[0].length;
      currentSection = {
        type: 'heading',
        text: trimmedLine.replace(/^#+\s*/, ''),
        level: Math.min(level, 3)
      };
    } else if (trimmedLine.startsWith('•') || trimmedLine.startsWith('-')) {
      if (currentSection) sections.push(currentSection);
      currentSection = {
        type: 'list',
        text: trimmedLine.replace(/^[•-]\s*/, '')
      };
    } else {
      if (currentSection && currentSection.type === 'paragraph') {
        currentSection.text += ' ' + trimmedLine;
      } else {
        if (currentSection) sections.push(currentSection);
        currentSection = {
          type: 'paragraph',
          text: trimmedLine
        };
      }
    }
  });

  if (currentSection) sections.push(currentSection);
  return sections;
}

module.exports = {
  htmlToDocxBuffer,
  parseHtmlToSections
};
